# Web をささえる技術

# 第一部 Web 概論

## 第一章 Web とは何か

---

## 第一部

1.1 全ての基盤である Web  
現在の最も重要なソフトウェアは、Web を閲覧するソフトウェア、ブラウザである。
Web は私たちの生活に根付いている

---

## 1.2 様々な Web の用途

- Web サイト  
  ポータルサイトや、ショッピングサイトブログなど
  Web サイトの裏がどのような構成になっているかクライアント側が意識しないで済むことは Web の大きな特徴

- ユーザーインターフェースとしての Web  
  Web の技術はユーザーインターフェースの分野でも使われている  
  例としてデバイスの設定画面など etc
  リモコンやハードウェアの限定されたボタンで設定するよりもブラウザ上で PC のキーボードで操作した方が効率的なことが理由の一つ。

- プログラム用 API としての Web  
  API はプログラム向けのインターフェース  
  データフォーマットには XML や JSON が利用される

---

## 1.3 Web を支える技術

- HTTP、URI、HTML  
  Web を支える最も基本的な技術は HTTP と URI と HTML。
  世界中のあらゆる情報を指し示すことができる
  これらの技術はシンプルな技術。
  このシンプルさのおかげで Web は色々な応用が可能になってくる

- ハイパーメディア  
  様々なメディアをハイパーリンクで結びつけて構成したシステム。  
  ハイパーメディアは非線形的にユーザーが自分でリンクを選択して情報を取得できる。

- 分散システム  
  一つの中央コンピューターがすべてを処理する形式を集中システムと呼ぶのに対して、複数のコンピューターを分散させる形式を分散システムと呼ぶ。  
  プロトコルがシンプルだからこそ、これだけの規模のシステムが実現できている。

---

## 第 2 章 Web の歴史

---

2.1 Web 以前のインターネット  
初期のインターネットには Web がなかった。  
インターネットの起源は 1969 年に構築された ARPNET までさかのぼる。  
米国内の大学や研究機関の間を当時としては高速の回線で接続し全米を繋ぐネットワークとして成長していった。

---

## 2.2 Web 以前のハイパーメディア

ハイパーメディアは 50 年以上歴史を持つ古い技術。

- Memex  
  ハイパーメディアの起源は ARPNET の誕生からさらにさかのぼった 1945 年に米国の研究者が発表したが Memex という情報検索システムについての論文だといわれている。
  Memex 構想にはハイパーメディアという言葉こそ登場しなかったが多くの研究者に影響を与えた。

- Xanadu  
  Memex の思想に影響を受けた研究者が現在の Web をさらに進化させた機能を持つ理想的なハイパーメディア Xanado(ザナドゥ)を構想し、開発を始める。  
  高機能故の複雑さから頓挫し、失敗に終わる。

- HyperCard  
  Web 以前に成功を収めたハイパーメディアとして 1987 年にアップルが開発した HyperCard がある。  
  HyperCard はネットワークを通じてデータをやり取りする機能こそなかったがカードと呼ばれる文章を単位に相互にリンクを張り、スクリプト言語 HyperTalk によるプログラムを実行できるいわばスタンドアロンの Web サービス。HyperCard は成功を収め、たくさんのゲームやアプリケーションが開発された。

---

## 2.3 Web 以前の分散システム

分散システムも Web 以前からある技術。  
Web 以前の分散システムはハードウェアにしろソフトウェアにしろ数を限定した均一なクライアントが前提だった。  
これでは世界規模で動作するシステムにはならない。

---

## 2.4 Web の誕生

1980 年代までにハイパーメディア構想が生まれ、インターネットが登場し、複数のコンピューターが接続した分散システムが構築された。  
Web はこのような時代環境に生まれた。

- ハイパーメディアとしての Web  
  Web はインターネットを使ったハイパーメディアとして設計された。  
  インターネットを利用しているため、不特定多数の情報をリンクさせることができ、システムを大規模化しやすいという特徴を持っている。  
  その反面情報の集中的な管理は難しくなり、リンク切れを起こしやすいといった欠点も持っている。

- 分散システムとしての Web  
  オープンで不特定多数を相手にするシステムが Web。  
  Web では世界中のユーザーが世界中の Web サービスを利用できる。  
  様々なブラウザやデバイスから１つの Web サービスにアクセスできる。  
  これはクライアントとサーバー間のインターフェースを HTTP というシンプルなプロトコルで固定したことで実現できている。

---

## 2.5 Web の標準化

爆発的な普及を果たした Web は様々なプレーヤーが参加してくる。  
学術的なコンテンツだけでなく、ニュースや娯楽メディアの参入、ショッピングサイトの登場などが挙げれる。

- Web の仕様策定  
  Web を構成する技術、特に HTTP と URI と HTML の標準化が求めれるようになる。  
  これらは各社のサーバー、クライアント間で利用され、相互運用性が求められたからである。  
  Web 技術を実装している会社が集まって標準化を行う段階として、1994 年に W3C(World Wide Web Consortium)が設立される。  
  W3C では HTML、XML、HTTP、URI、CSS などの標準化作業が行われた。
  特に HTML と CSS の標準化は重要だった。  
  ブラウザ戦争と呼ぶこともあるが、NetSpace NaviGator と Internet Explorer が独自拡張を繰り返した結果、両者での HTML と CSS のレンダリング結果が大きく異なり、開発者がブラウザごとの対応を迫られる事態になっていた。  
  ブラウザ対応という言葉はこの時代の名残。

- REST の誕生  
  Web の創成期から各種ソフトウェアの実装に関わっていたカリフォルニア大学の大学院生が Web がなぜこんなにも発展したのか、なぜこれほど大規模なシステムが成立したのかについてソフトウェアアーキテクチャの観点から分析を行い、１つのアーキテクチャスタイルとしてまとめた。  
  2000 年に彼はこのアーキテクチャスタイルを「REST」と名付け博士論文として提出。  
  HTTP はもともとハイパーテキストを転送するためのプロトコルだったが、実際にはハイパーテキスト以外の様々なものを運んでいる。  
  それが何かと言えばリソースの状態の表現というのが彼の主張だった。  
  そのため REST(Representational State Transfer)と名付けられた。

---

## 2.6 Web API をめぐる議論

しょきの Web は学術論文の交換に利用されていたため、主に人が文章を読むためのシステムだった。
Web の用途が多様化すると、プログラムから自動処理を行いたいという要求が出始める。  
1990 年代後半から 2000 年代前半にかけてプログラムから操作可能な Web API の議論が巻き起こる。

---

## 2.7 全てが Web へ

REST が普及していくにつれ Web はインターネット全体を飲み込み始める。  
別々のプロトコルを用いていたメールやネットニュースはバックエンドで動作しているプロトコルこそ変化していないが、少なくともユーザーインターフェースは全て Web で統一され始め、エンドユーザーは Web だけを意識するようになった。
この背景には Ajax や Comet などの技術的ブレークスルーがある。

---

## 第 3 章 REST Web のアーキテクチャスタイル

Web は世界的規模のハイパーメディアであり、分散システム。  
どちらも数十年の歴史を持っていて Web はその中で最も成功したシステム。  
Web システムの設計思想である REST についての解説。

---

## 3.1 アーキテクチャスタイルの重要性

REST は Web のアーキテクチャスタイル。  
アーキテクチャは別名「(マクロ)アーキテクチャパターン」とも言い複数のアーキテクチャに共通する性質、様式、作法、あるいは流儀を指す言葉。  
アーキテクチャスタイルには、例えば MVC(Model-View-Controller)やパイプ＆フィルター(Pipe & Filter)、イベントシステム(Event System)などがある。  
デザインとデザインパターンが違うように、アーキテクチャとアーキテクチャスタイルも別物。  
システムのアーキテクチャを決定する際の羅針盤となるのがアーキテクチャスタイル。

---

## 3.2 アーキテクチャスタイルとしての REST

REST は数あるアーキテクチャスタイルの中でも特にネットワークシステムのアーキテクチャ。  
ネットワークシステムのアーキテクチャスタイルとして最も有名なのがクライアント/サーバー(Client/Server)。 そして Web はクライアントサーバーでもある。
Web のアーキテクチャスタイルは REST でもあり、クライアント/サーバーでもある。  
REST はクライアント/サーバーから派生したアーキテクチャスタイルであり、クライアント/サーバーにいくつかの制約を加えることで REST というアーキテクチャスタイルになる。

---

## 3.3 リソース

REST における重要な概念の一つにリソース(Resource)がある。  
リソースとは Web 上に存在する名前を持ったありとあらゆる情報の事を指す。  
リソースの名前とは URI のことであり、WEB の情報である無数のリソースは URI という一意の名前を持っている。  
URI を用いることでプログラムはリソースが表現する情報にアクセスすることができる。

- リソースのアドレス可能性  
  URI が備えるリソースを簡単に指し示せる性質のことを「アドレス可能性」と呼ぶ。  
  きちんと名前がついており、適切な手段でアクセスできる状態にすると、プログラムをとても作りやすくなる。

- 複数の URI を持つリソース  
  １つのリソースは複数の URI を持つことができる。  
  リソースに別名の URI をいくつもつけると、クライアントがリソースにアクセスしやすくなる。  
  その反面どれが正式な URI なのかがわかりにくくなってしまうという欠点もある。

---

## 3.4 スタイルを組み合わせて REST を構成する

REST は複数のアーキテクチャスタイルを組み合わせて構築した複合アーキテクチャスタイル。
ここではクライアント/サーバーにアーキテクチャスタイルを追加して制約を課していくことで REST を構成していく。  
以下はアーキテクチャスタイル。

---

- クライアント/サーバー  
  Web は HTTP というプロトコルでクライアントとサーバーが通信するクライアント/サーバーというアーキテクチャスタイルを採用している。  
  クライアントはサーバーに対してリクエストを送りサーバーはそれに対してレスポンスを返す。  
  利点としてクライアントとサーバーを分離することで、クライアントをマルチプラットフォームにすることができる。(例として PC、携帯電話、ゲーム機など)  
  また、サーバーはデータストレージの機能だけを提供すればよくなる。さらに、複数のサーバーを組み合わせて冗長化することで可用性を挙げられる。

---

- ステートレスサーバー  
  ここでのステートレスとはクライアントのアプリケーション状態をサーバーで管理しないことを指す。  
  サーバーがアプリケーションの状態を持たないことの利点はサーバー側の実装を簡略化できる。  
  クライアント/サーバーにステートレス性を導入すると、クライアント/ステートレスサーバーになる。

---

- キャッシュ  
  キャッシュとはリソースの鮮度に基づいて一度取得したリソースをクライアント側で使いまわす方式のこと。  
  キャッシュの利点としてサーバーとクライアントの通信を減らすことができる。  
  ただし、古いキャッシュを利用してしまい、情報の信用性が下がる可能性もある。
  キャッシュを追加したアーキテクチャスタイルは、「クライアント/キャッシュ/ステートレスサーバー」と呼ぶ。

---

- 統一インターフェース  
  統一インターフェースとは URI で指し示したリソースに対する操作を統一したインターフェースで行うアーキテクチャスタイルのこと。  
  HTTP1.1 では GET や POST など８個のメソッドだけが定義されており、通常はこれ以上メソッドが増えない。  
  インターフェースの柔軟性に制限を加えることで、全体のアーキテクチャがシンプルになる。  
  また、インターフェースを統一することでクライアントとサーバーの実装の独立性が向上する。  
  統一インターフェースを追加したアーキテクチャスタイルを「統一/クライアント/キャッシュ/ステートレスサーバー」と呼ぶ。

---

- 階層化システム  
  統一インターフェースの利点の一つにシステム全体が階層化しやすいということがある。  
  Web サービスではサーバーとクライアントの間にロードバランサーを設置して負荷分散をしたり、プロキシを設定してアクセスを制限したりする。  
  クライアントからするとサーバーもプロキシも同じインターフェースで接続できるので接続先がサーバーからプロキシに変わったことを意識する必要がない。  
  これはサーバーやプロキシなどの各コンポーネント間のインターフェースを HTTP で統一していることから実現できている。  
  このようにシステムをいくつかの階層に分離するアーキテクチャスタイルのことを階層化システムと呼ぶ。  
  階層化システムを追加したアーキテクチャスタイルを「統一/階層化/クライアント/キャッシュ/ステートレスサーバー」と呼ぶ。

---

- コードオンデマンド  
  コードオンデマンドはプログラムコードをサーバーからダウンロードし、クライアント側でそれを実行するアーキテクチャスタイル。  
  例として JavaScript など etc  
  コードオンデマンドの利点はクライアント側を後から拡張することができること。  
  コードオンデマンドの欠点として、ネットワーク通信におけるプロトコルの可視性が低下する。  
  しかし近年の Web では JavaScript などのクライアント側で実行する重要度は増すばかり。
  コードオンデマンドを追加したアーキテクチャスタイルを「統一/階層化/コードオンデマンド/クライアント/キャッシュ/ステートレスサーバー」と呼ぶ。

---

## 3.5 REST の二つの側面

- REST とハイパーメディア  
  ハイパーメディアを用いたアプリケーションにはリソースの URI さえ分かれば、あるアプリケーションが提供しているリソースをほかのアプリケーションが簡単に再利用できるという利点がある。  
  リソースをリンクと接続することで 1 つのアプリケーションを構成するという考え方は REST の基幹をなす思想。  
  この考え方は「接続性」とも呼ばれる。

- REST と分散システム  
  RPC や CORBA、DCOM などの分散オブジェクトでは関数やメソッド単位でサーバー側の処理を呼び出す。  
  ネットワーク越しの関数呼び出しは同一プロセス内の関数呼び出しとは比べ物にならないオーバーヘッドがあるので、システム全体の性能劣化を引き起こす。  
  REST を用いた Web サービスではリンクをたどることでアプリケーションを実現している。  
  リソースはそれ自体で意味を持つひとかたまりのデータであり、RPC の関数でやり取りされるデータよりも粒度が大きいものになる。  
  従って、リンクをたどってアプリケーション状態を遷移する方が全体として性能劣化が抑えれる。

---

## 3.6 REST の意義

REST は Web 全体のアーキテクチャスタイルである。  
私たちが作成する Web サービスや WebAPI は Web を構成する一部になる。  
個別の Web サービスや WebAPI が RESTfull になると Web は全体としてよくなる。

---

# 第二部 URI

## 第 4 章 URI の仕様

URI の仕様を正しく理解することは、使いやすい Web サービスや WebAPI への第一歩

---

## 4.1 URI の重要性

URI は Uniform Resource Identify の略で直訳すると「統一リソース識別子」となる。  
つまり URI とはリソースを統一的に識別する ID のこと。  
URI を使用すると、Web 上にあるすべてのリソースにアクセスできる。

---

## 4.2 URI の構文

```
http/blog.example.jp/entries/1
```

この URI を構成するパーツは以下の通り。

- URI スキーム : http
- ホスト名 : blog.example.jp
- パス : /entries/1

複雑な URI として以下のようなものがある。

```
http/hogehoge:pass@blog.example.jp:8000/search?q=test&debug=true#n10
```

この URI は以下に分けられる。

- URI スキーム : http
- ユーザー情報 : hogehoge:pass
- ホスト名 : blog.example.jp
- ポート番号 : :8000
- パス : /search
- クエリパラメーター : q=test&debug=true
- URI フラグメント : #n10

---

## 4.3 絶対 URI と相対 URI

URI のパスは UNIX のファイルシステムと同じような階層構造を持っている。  
/をルートにしてディレクトリ名を/で区切り、必要であれば最後にファイル名を接続する記法。  
OS のファイルシステムでは、ルートから記述したパスのことを絶対パスと呼ぶ。
OS のファイルシステムの場合毎回絶対パスを記述するのは冗長なのでコマンドラインからディレクトリやファイルの位置を指定する時はカレントディレクトリからの相対パスで表現するのが一般的。  
OS のファイルシステムと同様に URI にも絶対 URI と相対 URI がある。
相対 URI は、URI やホスト名を省いて、パスだけで表現する。

絶対パス

```
http://example.jp/foo/bar
```

相対パス

```
/foo/bar
```

---

## 4.4 URI と文字

- URI で使用できる文字  
  アルファベット : A-Za-z  
  数字 : 0-9  
  記号 : -.~:@!$&'()  
  この文字列は ASCIL 文字と言われる。
  日本語などの ASCIL 以外の文字を入れるときは％エンコーディングという方式をとる。

- %エンコーディング  
  URI 使用が許可している文字以外を URI に入れるには％エンコーディングが必要。  
  %という文字は％エンコーディングで用いられるので、URI に直接いれることができない。

---

## 4.5 URI の長さ制限

仕様上は URI の長さに制限はない。  
しかし実装上は制限が存在する可能性がある。

---

## 4.6 様々なスキーム

URI スキームの公式な一覧は IANA(アイアナ)に登録されている。  
名前空間には http スキームなど既存のスキームを指定すればよい。  
URI スキームを新たに登録しなくてはいけない場合は従来にないプロトコルを発明したときくらいと考えるべき。

---

## 4.7 URI の実装で気を付けること

Web サービスや WebAPI の実装で URI の仕様上気を付けるべきなのは、相対 URI の解決と、%エンコーディングの扱いの 2 点。  
クライアントで相対 URI を解決するには面倒な処理が必要になるので、Web サービスや WebAPI を実装する場合はなるべく絶対 URI を使った方がクライアントにとって親切。  
URI に ASCIL 文字以外を入れる場合には、%エンコーディングの文字コーディングとしてなるべく UTF-8 を用いるのが望ましい。

---

## 第 5 章 URI の設計

## 5.1 クールな URI は変わらない

よい URI やきれいな URI のことをクール URI と呼ぶ。  
リンクが切れてしまうことは、ハイパーメディアシステムが機能しないことを意味する。  
URI は変わらないべきである。変わらない URI こそが最上の URI という主張がクール URI に込められている。

---

## 5.2 URI を変わりにくくするためには

会社の倒産を Web サービスで防ぐことは難しいが、変わりにくい URI で Web サービスを構築することはできる。

- プログラミング言語に依存した拡張子やパスを含めない
- メソッド名やセッション ID を含めない
- URI はリソースを表現する名詞にする

---

## 5.3 URI のユーザービリティ

シンプルな URI には利点がある。  
覚えやすく、開発者ではない普通の人にも使いやすい。それがクール URI の良い点。

---

## 5.4 URI を変更したいとき

どうしても URI を変更したいときはできる限りリダイレクトするようにする。  
リダイレクトとは古い URI を新しい URI に転送する HTTP の仕組み。

---

## 5.5 URI 設計のテクニック

拡張子は URI の設計に用いるべきではないと前述してあるが、それは実装に依存した拡張子だから。  
依存しない拡張子は良い側面もある。

- コンテントネゴシエーション  
  HTTP にはコンテントネゴシエーションという便利な機能があり、日本語版の OS を使っているユーザーには日本語を、英語版の OS を使っているユーザーには英語を返すことができる。

- 言語を指定する拡張子  
  コンテントネゴシエーションの場合、日本語 OS の利用者は英語版のプレスリリースを取得する場合、ブラウザの設定を変更しなくてはならない。  
  日本語版も英語版も簡単にアクセスできるようにリソースの言語を明示的に使用したつぎの URI を使う。

```
http://hogehoge.jp/press.jp
```

```
http://hogehoge.jp/press.en
```

---

## 5.6 URI の不透明性

シンプルな URI は可読性が高いため、ユーザーが URI の構造を把握しやすくなる。  
先の例でフランス語版を推測すると以下になる。

```
http://hogehoge.jp/press.fn
```

しかしこの URI にアクセスしてもリソースがあることは限らない。  
このようにクライアント側から URI を組み立てたり、拡張子からリソースの内容を推測したりできないことを URI の不透明性という。

---

## 5.7 URI を強く意識する

URI はともするとアプリケーションフレームワークが隠蔽して通常のプログラマーが意識しなくてもよいそんざいになってしまいがち。  
しかし URI は次の点でとても重要。

- URI はリソースの名前である
- URI は寿命が長い
- URI はブラウザがアドレス欄に表示する

これらの視点から URI は Web サービスや WebAPI の設計において最も重要視するべきパーツであるといえる。

---

## 第３部 HTTP

## 第 6 章 HTTP の基本

---

## 6.1 HTTP の重要性

HTTP は RFC2616 で規定されたプロトコル。  
HTTP は REST の重要な特徴である統一インターフェース、ステートレスサーバー、キャッシュなどを実現している、Web の基盤となるプロトコルです。

---

## 6.2 TCP/IP とは何か

HTTP は TCP/IP をベースにしている。  
TCP と IP はインターネットの基盤を構成する重要なネットワークプロトコル。

---

## 6.3 HTTP のバージョン

現在(2010)最も広く利用されている HTTP のバージョンは 1.1。  
ブラウザ戦争が一番激しかった時代に仕様作成作業がおこなわれていた。  
HTTP1.0 ではヘッダの導入、GET 以外のメソッドの追加など HTTP1.1 につながる基本的な要素が盛り込まれた。  
HTTP1.1 では、HTTP1.0 の機能に加えチャンク転送、Accept ヘッダによるコンテントネゴシエーション、複雑なキャッシュコントロール、持続的接続などの機能を追加している。

---

## 6.4 クライアントとサーバー

Web はアーキテクチャスタイルにクライアント/サーバーを採用している。
クライアントが情報を提供するサーバーに接続し、各種リクエストを出して、レスポンスを受け取る。

---

## 6.5 リクエストとレスポンス

前述のとおり HTTP ではクライアントが出したリクエストをサーバーで処理してレスポンスを返す。
このようなプロトコルのことをリクエスト/レスポンス型のプロトコルと呼ぶ。  
サーバーでの処理に時間がかかる場合でも、リクエストを出したクライアントはレスポンスが返るまで待機する。これは HTTP が同期型のプロトコルであるため。

---

## 6.6 HTTP メッセージ

リクエストメッセージとレスポンスメッセージをまとめて HTTP メッセージと呼ぶ。

---

## 6.7 HTTP のステートレス性

HTTP とはステートレスなプロトコルとして設計されている。  
ステートレスとは「サーバーがクライアントのアプリケーション状態を保存しない」制約のこと。

---

## 6.8 シンプルなプロトコルであることの強み

HTTP の一番の特徴はそのシンプルさ。  
HTTP のシンプルさは強力な武器。  
HTTP がシンプルであるからこそブラウザは PC だけでなく、様々なデバイスでも実装されている。  
また、そのシンプルさ故に Web サービスと WebAPI が同じプロトコルで実現できている。  
HTTP のシンプルさを活かした設計をするためには、HTTP の使い方を正確に知る必要がある。

## 第 7 章 HTTP メソッド

---

## 7.1 8 つしかないメソッド

HTTP メソッドには、クライアントが行いたい処理をサーバーに伝えるという重要な役割がある。  
通常のプログラミング言語の感覚すると、それで大丈夫かと不安になるが、メソッドの数をギリギリまで削ったからこそ HTTP が、そして Web が成功したといえる。

---

## 7.2 HTTP メソッドと CRUD

HTTP メソッドのうち GET、POST、PUT、DELETE はこれら４つで「CRUD」という性質を満たすため、代表的なメソッドといえる。  
Create,Read,Update,Delete というデータ操作の基本となる４つの処理のこと。

---

## 7.3 GET リソースの取得

GET は指定した URI の情報を取得する。  
もっとも利用頻度の高いメソッドで Web ページの取得、画像の取得、映像の取得、フィードの取得などブラウザを利用している際に常に多くの GET を発行している。

---

## 7.4 POST リソースの作成、追加

POST は GET につづいて利用頻度が高いメソッド。  
POST の代表的な機能はあるリソースに対する子リソースの作成がある。  
子リソースの作成ほど一般的ではないが、POST の代表的な機能の 2 つ目は既存リソースへのデータの追加がある。  
URI をみただけでは POST の挙動はわからない。  
POST の挙動は Web サービスや WebAPI の仕様書などで表現する。  
ほかのメソッドでは対応できない処理を POST で代用できることも POST 機能の一つ。

---

## 7.5 PUT リソースの更新、作成

PUT は 2 つの機能を持っている。

- リソースの更新  
  あるリソースの値を更新する時に使用する
- リソースの作成  
  存在しないリソースを新しく作成する時に使用する

POST の PUT のリソース作成の使い分けについての正解はないが、設計上の指針として次の事実がある。

POST でリソースを作成する場合、クライアントはリソースの URI を指定できない。URI の決定権はサーバー側にある。  
PUT でリソースを作成する場合リソースの URI はクライアントが決定する。

特別な事情がない限りは、リソースの作成は POST で行い、URI もサーバー側で決定するという設計が望ましい。

---

## 7.6 DELETE リソースの削除

DELETE はその名の通り、リソースを削除するメソッド。

---

## 7.7 HEAD リソースのヘッダの取得

HEAD は GET によく似たメソッド。  
GET はリソースを取得するのに対して、HEAD はリソースのヘッダ（メタデータ）だけを取得するメソッド。  
HEAD のレスポンスにはボディが含まれない。
この性質を利用すると、ネットワークの帯域を節約しながらリソースの大きさを調べたり、リソースの更新日時を取得したりできます。

---

## 7.8 OPTIONS リソースがサポートしているメソッドの取得

OPTIONS はそのリソースがサポートしているメソッドの一覧を返す。
レスポンスに含まれる Allow ヘッダはそのリソースが許可するメソッドの一覧。  
OPTIONS を実装する場合、多くの Web アプリケーションフレームワークではリソースごとに対応しているメソッドを返すように自前で実装しなくてはならない。

---

## 7.9 POST で PUT/DELETE を代用する方法

今までのメソッドの中で現実によく利用されるものが GET と POST。  
これは HTML のフォームで指定できるメソッドが GET と POST だけという制限に起因する。  
しかしこの制限は Ajax の発展により解決しつつある。
Ajax の持つ XMLHttpRequest というモジュールを利用すると、任意のメソッドを発行できるため。

---

## 7.10 条件付きリクエスト

HTTP メソッドと更新日時などのヘッダを組み合わせることで、メソッドを実行するかどうかをリソースの更新日時を条件にサーバーが選択できるようにようになる。  
このようなリクエストを条件付きリクエストと呼ぶ。

---

## 7.11 べき等性と安全性

通信エラーが起きた際にリクエストどのように回復するかは、HTTP において重要な課題となる。  
HTTP の仕様では、プロトコルのステートレス性を保ちながら、この問題を解決するための工夫がなされている。  
べき等とはある操作を何回行っても結果が同じことを意味する数学用語。  
PUT や DELETE はべき等性なので同じリソースに何回発行しても、必ず同じ結果が得れれるようになっている。（リソースの内容が更新されている、リソースが削除されている）  
安全とは操作対象のリソースの状態を変化させないことを意味する。  
GET には副作用（リソースの変化）がないので、GET を同じリソースに何回発行してもリソースの状態は変化しないので安全であるといえる。

---

## 7.12 メソッドの誤用

GET と HEAD がべき等かつ安全で、PUT と DELETE がべき等であることは HTTP の使用に定めれている。  
しかし Web サービスや Web の API の設計を誤ると、これらのメソッドが安全でなくなったり、べき等でなくなったりする可能性がある。

---

## 7.13 Web の成功利用は HTTP メソッドにあり

HTTP が非常に少ないメソッドで成り立っていることが、REST の統一インターフェース制約。  
メソッドを限定したからこそプロトコルがシンプルに保たれ Web は成功することができた。

## 8 章 ステータスコード

---

## 8.1 ステータスコードの重要性

Web サービスや WebAPI を設計するにあたって、ステータスコード
をどのように選択するかはとても重要。  
レスポンスに間違ったステータスコードを割り当ててしまうと、クライアントが混乱しシステム全体の挙動に支障をきたす。  
仕様で定めれれたステータスコードの意味を正しく理解することが重要。

---

## 8.2 ステータスコードのおさらい

レスポンスメッセージの一行目にあるステータスラインは、プロトコルのバージョン、ステータスコード、テキストフレーズから成る。  
テキストフレーズにはステータスコードに対応した説明句が入るが、これは人間用の為仕様で例示している以外のフレーズも入れられる。

---

## 8.3 ステータスコードの分類と意味

HTTP1.1 のステータスコードは RFC の 2616 の 6.1.1 節で定義されている。  
この定義にはステータスコードは 3 桁の数字であり、先頭の数字によって次の 5 つに分類すると書かれている。

- 1xx 処理中  
  処理が継続している事を示す。  
  クライアントはそのままリクエストを継続するか、サーバーの指示に従ってプロトコルをアップデートして再送信する。

- 2xx 成功  
  リクエストが成功したことを示す

- 3xx リダイレクト  
  ほかのリソースへのリダイレクトを示す。  
  クライアントはこのステータスコードを受けっとった時、レスポンスメッセージの Location ヘッダを見て新しいリソースへ接続する。

- 4xx クライアントエラー  
  クライアントエラーを示す。  
  原因はクライアントのリクエストにある。  
  エラーを解消しない限り正常な結果が得られないので、同じリクエストをそのまま再送信することができない。

- 5xx サーバ-エラー
  サーバーエラーを示す。
  原因はサーバー側にある。サーバー側の原因が解決すれば同一のリクエストを再送信して正常な結果を得られる可能性がある。

---

## 8.4 よく使われるステータスコード

- 200 OK リクエスト成功  
  200 OK はリクエスト成功したことを示す。  
  PUT や POST の場合はボディに処理結果が入る。

- 201 Created リソースの作成成功  
  201 はリソースを新たに作成したことを示す。  
  POST や PUT のレスポンスとして返る。  
  レスポンスボディには慣習的に新しく作成したリソースの表現をいれることが多いが特に何も入れなくても問題はない。  
  POST の場合、新しく作成したリソースの URI はレスポンスの Location ヘッダに絶対 URI として入る。

- 301 Moved Permanently リソースの恒久的な移動  
  301 Moved Permanently はリクエストで指定したリソースが URI に移動したことを示す。  
  新しい URI はレスポンスの Location ヘッダに絶対 URI として入る。

- 303 See Other 別 URI の参照  
  303 See Other は、リクエストに対する処理結果が別の URI で取得できることを示す。  
  典型的にはブラウザから POST でリソースを操作したけっかを GET で取得するときに使う。

- 400 BadRequest リクエストの間違い  
  400 BadRequest はリクエストの構文やパラメーターが間違っているときを示す。  
  400 BadRequest は他に適切なクライアントエラーを示すステータスコードがない場合にも用いる。

- 401 Unauthorized アクセス件不正  
  401 Unauthorized は適切な認証情報を与えずにリクエストを行ったことを示す。  
  レスポンスの WwW-Authenticate ヘッダでクライアントに対して認証方式を伝える。

- 404 BadRequest Not Found リソースの不在  
  404 BadRequest は指定したリソースが見つからないことを示す。  
  レスポンスボディにはその理由が入る。

- 500 Internal Server Error サーバー内部エラー  
  500 Internal Server Error はサーバー側に何らかの異常が生じていて、正しいレスポンスが返せないことを示します。  
  レスポンスボディには異常の理由が入る

- 503 Service Unavailable サービス停止  
  503 Service Unavailable はサーバーがメンテナンスなどで 一時的にアクセスできないことを示す。  
  レスポンスボディにはその理由入る。  
  レスポンスの Retry-After ヘッダでサービス再開時間がおよそ何秒後かであるかを通知することができる。

---

## 8.5 ステータスコードとエラー処理

4xx 系と 5xx 系はステータスコードはどちらもエラーを表現します。  
エラーコードは HTTP が仕様が規定しているがボディにどんなエラーメッセージを入れるかは規定していない。  
WebAPI の場合クライアントが解釈できる形式でエラーメッセージを返してあげるというのは親切な実装。

---

## 8.6 ステータスコードの誤用

Web サービスでも WebAPI でも HTTP のステータスコードを正しく使うことは最低限のマナー。  
しかし一部の Web サービスや WebAPI ではエラーを 200 OK で返すことがある。

---

## 8.7 ステータスコードを意識して設計する

ステータスコードは大きく 5 種類に分類でき、それぞれに意味がある。  
ステータスコードは仕様で固定されているので自分で自由にというわけにはいかない。  
大切なのはステータスコードを正しく使うこと。  
開発している Web サービスや WebAPI でエラーが起きた時にそのステータスコードを返すかはとても重要な設計の検討事項になる。

---

## 第 9 章 HTTP ヘッダ

---

## 9.1 HTTP ヘッダの重要性

ヘッダは、メッセージのボディに対する付加的な情報、いわゆるメタデータを表現する。  
クライアントやサーバーはヘッダを見てメッセージに対する挙動を決定する。  
また、リソースのアクセス件を決定する認証や、クライアントとサーバーの通信回数と量を減らすキャシュなどの機能は、ヘッダをメソッドやステータスと組み合わせることで実現できる。

---

## 9.2 HTTP ヘッダの生い立ち

HTTP の仕様策定が進められるに従って、HTTP で転送する本文のメタデータを表現するために電子メールのメッセージ仕様（RFC822）のヘッダ形式を借りてくる形で追加された。  
電子メールプロトコルとの大きな違いはメールプロトコルが一方向にしかメッセージのやり取りをしないのに対し、HTTP は一度の通信でリクエスト/レスポンスの２つのメッセージをやり取りする点。  
このため電子メールにはない様々なヘッダが追加されている。

---

## 9.3 日時

値に日時を持つヘッダ。  
Date や Expires が相当する。  
HTTP では電子メールに合わせた日時フォーマットを利用する。  
HTTP では日時は全て GMT で記述することになっている。  
これによってサマータイムなどの複雑な問題を回避できる。

---

## 9.4 MIME メディアタイプ

メッセージでやるとりするリソースの表現の種類を指定するのが MIME メディアタイプ。  
これも電子メールから拝借してきた仕様。

- Content-Type メディアタイプを指定する  
  Content-Type ヘッダはメッセージボディの内容がそのような種類なのかをメディアタイプで示す。

- Charset パラメーター 文字エンコーディングを指定する  
  メディアタイプは Charset パラメーターを持つことができる。

---

## 9.5 言語タグ

リソース表現の自然言語を指定するヘッダ。  
Content-Language ヘッダの値は「言語タグ」と呼ばれる文字列。  
言語タグの「-」の左側には ISO639 が定義する言語コードが入る。  
「-」の右側には iso3166 が定義する地域コードが入る。

例

```
Content-Language: ja-jp
```

---

## 9.6 コンテントネゴシエーション

メディアタイプや文字エンコーディング、言語タグは、サーバーが一方的に決定するだけでなく、クライアントと交渉して決めることもできる。  
この手法をコンテントネゴシエーションと呼ぶ。

- Accept 処理できるメディアタイプを伝える  
  クライアントが処理できるメディアタイプをサーバーに伝える場合 Accept ヘッダを利用する。

- Accept-Charset 処理できる文字エンコーディングを伝える  
  クライアントが処理できる文字エンコーディングをサーバーに伝える場合 Accept-Charset ヘッダを利用する。

- Accept-Language 処理できる言語を伝える  
  クライアントが処理できる言語タグをサーバーに伝える場合 Accept-Language ヘッダを利用する。

---

## 9.7 Content-Length とチャンク転送

- Content-Length  
  メッセージがボディを持っている場合、基本的には Content-Length ヘッダを利用して、そのサイズを 10 進数のバイトで示す。  
  あらかじめサイズのわかっているリソースを転送する場合は Content-Length ヘッダを利用するのが簡単。

- チャンク転送 ボディを分割して転送する  
  ファイルサイズが決まるまでレスポンスを返せないと応答性能が低下する。  
  そのような時に Trance-Encoding ヘッダを使用する。

---

## 9.8 認証

現在(2010 年)主流の HTTP 認証方式には HTTP1.1 が定めている Basic 認証と Digest 認証がある。  
また、WEB API では WSSE という HTTP 認証の拡張仕様を利用する場合がある。 リソースにアクサス制限がかかっている場合、ステータスコード 401(Unauthorized)と WWW-Authenticate ヘッダを利用して、クライアントに必要な認証情報を通知できる。  
401 Unauthorized は認証が失敗したときなどにも返ってくるエラーコード。

- Basic 認証  
  Basic 認証はユーザー名とパスワードによる認証方式。  
  ユーザー名とパスワードは Authorization ヘッダに入れてリクエストごとに送信する。  
  Basic 認証を使用する場合、ユーザー名とパスワードは Base64 エンコードされた文字列になる。  
  これは簡単にもとの文字列に戻せてしまうため、Basic 認証を行う際はそれが許される程度のセキュリティ強度でよいのか、SSL や TLS を使って HTTPS 通信し、通信路上で暗号化するべきなのかを検討しなくてはならない。

- Digest 認証  
  Digest 認証は、Basic 認証よりもセキュアな認証方式。  
  Digest 認証のダイジェストとはメッセージダイジェストの略であるメッセージに対してハッシュ関数を適用した結果のハッシュ値のこと。  
  サーバーから WWW-Authenticate ヘッダの値（チャレンジ）を取得したクライアントはユーザー名とパスワードを使ってダイジェストを生成する。  
  生成したダイジェストを response というフィールドに入れてリクエストをすることで認証をする。
  Digest 認証の利点としてサーバー上にパスワードのハッシュ値を保管しておけばパスワードそのものを保管する必要がないことはメリットとしてあげられる。  
  Digest 認証ではパスワードが流出する可能性はないが、メッセージは暗号化されない。
  メッセージを暗号化したい場合は Basic 認証と同様に HTTPS を使用する。

- WSSE 認証

- OpenID シンプルなシングルサインオン  
  OpenID はシンプルなシングルサインオンを実現する仕組み。  
  ある Web サービスのアカウントをほかの WEB サービスでもログインできるようになる。

- OAuth  
  OAuth は WEB サービス間でデータをやり取りする仕組み。  
  認可情報を委託することでデータをやり取りする。

---

## 9.9 キャシュ

キャシュとは、サーバーから取得したリソースをローカルストレージ（ハードディスクなど）に蓄積し、再利用する手法のこと。
クライアントが蓄積したキャシュはそのキャシュが有効な間、クライアントが再度そのリソースにアクセスしようとしたときに再利用する。

---

## 9.10 持続的接続

http1.1 での大きな新機能が持続的接続。  
http1.0 では、クライアントが TCP コネクションを確立してサーバーがそれにレスポンスを返す度に TCP コネクションを切断していた。  
そのため画像や外部 CSS ファイルにたくさんリンクしている WEB ページを表示しようとすると、どうしてももっさりとした動作にならざるおえなかった。  
これを解決するために、クライアントとサーバー間でリクエストのたびに接続するのではなく、まとめて接続し続ける手法が開発された。  
HTTP1.1 ではこの持続的接続がデフォルトの動作になった。  
持続的接続ではクライアントとレスポンスを待たずに同じサーバーにリクエストを送信できる。これを「パイプライン化」と呼ぶ。

---

## 9.11 その他の HTTP ヘッダ

上記の HTTP ヘッダのほかにも HTTP の標準ではないがよく使われるヘッダがある。

- Content-Disposition ファイル名を指定する
  Content-Disposition ヘッダとはサーバーがクライアントに対してそのリソースのファイル名を提示する際に使用する。

- Slug ファイル名のヒントを指定する  
  AtomPub が追加した拡張 HTTP ヘッダに Slug がある。  
  Slug ヘッダを利用すれば、クライアントが Atom のエントリを POST する際に、新しく生成するリソースの URI のヒントとなる文字列をサーバーに提示できる。

---

## 9.12 HTTP ヘッダを活用するために

ヘッダはメソッドやステータスコードと組み合わせて、認証やキャシュなどの HTTP の重要な機能を実現している。  
電子メールや文字コーディングは Web よりもさらに長い歴史を持っているため、バットノウハウの塊。  
HTTP ヘッダを上手に使うためにはこれらの歴史と実際のサーバーやブラウザの実装を調査する能力が必要となる。

---

## 第 10 章 HTML

HTML は HTTP、URI と共に Web の誕生日生まれた。  
Web にとっては基本的な技術の一つ。  
Web の重要な側面の一つ、であるハイパーメディアを実現している。

---

## 10.1 HTML とは何か

HTML とは Hyper Markup Language の略。  
マークアップ言語とはタグで文章を構造を実現するコンピューター言語。  
マークアップ言語でマークアップした構造をもった文章のことを「構造化文章」と呼ぶ。

---

## 10.2 メディアタイプ

HTML のメディアタイプには「text/html」と「application/xhtml と xml」の 2 種類がある。  
「text/html」は SGML ベース HTML を、「application/xhtml/xml」は XML ベースの XHTML を示す。  
どちらのメディアタイプを使う場合でも charset パラメータを付けて文字エンコーディングを指定できる。  
HTML の文字コーディングは特別な理由がない限り UTF-8 を使用するのが無難。

---

## 10.3 拡張子

HTML には「.html」または「.htm」という拡張子を用いる。  
.htm は古い OS の制限によるものなので.html を使用するのが一般的。  
明示的に HTML 表現を取得したい場合は、URI に.html をつけるようにリソース設計するとよい。

---

## 10.4 XML の基礎知識

HTML/XHTML の書式を学ぶためには、メタ言語である XML の仕様を知らなければならない。

- XML の木構造  
  XML 文章は木構造として表現できる。

- 要素  
  XML は要素(element)で文章の構造を表現する。  
  要素は開始タグ(Start Tag)、内容(Content)、終了タグ(End Tag)から成る。  
  タグには要素名が入り、開始タグは<要素名>、終了タグは</要素名>と記述する。

- 属性  
  要素は属性(Attribute)を複数持つことができる。  
  属性は属性名と属性値の組みで、開始タグの中に属性名＝"属性値"という形式で記述する。  
  属性名、属性値共に文字列。  
  開始タグは属性を複数持てるが、同じ名前の属性は 1 つだけしか記述できない。  
  また、属性は入れ子にできず、開始タグの属性の順番には意味がない。

---

## 10.5 HTML の構成要素

HTML の最も基本的な構成要素はヘッダとボディ。  
HTTP メッセージと同様にヘッダには文章のメタデータを、ボディには文章の内容そのものをいれる。

- ヘッダ  
  ヘッダに入る要素を指定できるメタデータを表に示す。

- ボディ  
  ボディにはいる要素は大きくブロックレベル要素とインライン要素に分かれる。

  - ブロックレベル要素  
    ブロックレベル要素は文章の段落や見出しなどある程度大きな塊を表現する。
  - インライン要素  
    インライン要素はブロックレベル要素に入る要素で、協調や改行、画像埋め込みなどを表現する。

- 共通の属性
  HTML の全ての要素は id 属性と class 属性を持つことができる。

  - id 属性  
    文章内で一意な ID。文章内のある部分を URI で示すときに URI フラグメントで利用したり、CSS でスタイルを指定したりするときに利用する。

  - class 属性
    その要素が属性するクラス。  
    その要素がどのような意味を持つのかを指定するメタデータとしての役割がある。  
    CSS でのスタイル指定や、microformats などでメタデータを表現するときに指定する。

---

## 10.6 リンク

- a 要素  
  HTML ではほかの Web ページにリンクするためにアンカーリタグである a 要素を使用する。  
  a 要素の内容のことをアンカーテキストと呼ぶ。

- link 要素  
  a 要素は HTML のブロック要素の中での別の Web ページにリンクするために用いたが、link 要素は HTML のヘッダで Web ページ同士の関係を指定するために使う。

- フォーム  
  a 要素や link 要素とは少し異なるリンクの実現手段として、フォームがある。  
  HTML のフォームではリンク先の URI に対して GET と POST が発行できる。  
  フォームの基本構造は、form 要素とその中に入るフォームコントロール要素。  
  フォームコントロール要素には、テキスト入力(input)やラジオボタン、セレクトボックスなどがある。

---

## 10.7 リンク関係

ブラウザのように操作をするのが人間であれば、アンカーテキストを読むことでリンクの意味を理解できる。  
しかし、WebAPI のようにプログラムがクライアントの場合は、それぞれのリンクがどのような意味かを解釈し、どのリンクを辿るべきかを機械的に判断する仕組みが必要。

- rel 属性  
  a 要素と link 要素はそれぞれ rel 属性を持てる。  
  rel 属性の値にはリンク元のソースとリンク先のリソースがどのような関係にあるかを記述する。  
  rel 属性の値のことをリンク関係と呼ぶ。。  
  このリンク関係は元の HTML リソースを外部の CSS リソースにリンクするときに使う。

---

## 10.8 ハイパーメディアフォーマットとしての HTML

HTML で実現できる機能はシンプルなハイパーメディアのみだが、その効果は絶大。  
HTTP と URI、そしてハイパーメディアによるリンクを組み合わせて初めて Web が成り立つ。  
HTML でリンクを設計する際は、リンクをたどることでアプリケーション状態が遷移することを強く意識するべき。  
リソース同士きちんと接続してアプリケーション状態を表現できているかどうかは、HTML でリソースを表現する時の重要な設計指針になる。

---

## 11 章 microformats

HTML の中でさらに意味のあるデータを表現するための技術が microformats。  
microformats を用いると、リンクの細かい意味やイベント情報などを表現できる。

---

## 12 章 Atom

---

## 13 章 Atom Publishing Protocol

---

## 14 章 JSON

JSON は XML のように文章をマークアップすることには向いていない。  
ハッシュや配列といったプログラミング言語から扱いやすいデータ構造を記述できることが特徴。

---

## 14.1 JSON とは何か

JSON は JavaScript Object Notation の略で RFC4627 が規定するデータ記述言語。
その名が示すとおり JavaScript の記法でデータを記述できる点が最大の特徴。  
記法は JavaScript だが、そのシンプルさから多くの多くの言語がライブラリを用意しているため、プログラミング言語間でデータを受け渡せる。

---

## 14.2 メディアタイプ

JSON のメディアタイプは「application/json」。  
JSON は仕様上 UTF-8、UTF-16、UTF-32 のいずれかでエンコードすることになっているため最初の 4 バイトをチェックすれば自動的に文字エンコーディングを特定できるが、HTTP ヘッダなどのメディアタイで charset パラメーターも指定できる。

---

## 14.3 拡張子

JSON ファイルには「.json」という拡張子を用いることが推奨されている。  
明示的に JSON 表現を取得したいときは URI に「.json」を付けるとよい。

---

## 14.4 データ型

JSON に組み込みで用意されているデータ型には以下の６つがある。

- オブジェクト  
  オブジェクトは数値と値の集合。  
  名前と値の組をオブジェクトの「メンバ」と呼ぶ。  
  Javascript ではオブジェクトの名前に識別子や数値もとれるが、JSON ではメンバの名前は常に文字列になる。  
  メンバの値は文字列や数値、オブジェクトの配列など、JSON のデータ型であればなんでも入れられる。

- 配列  
  配列は順序をもった値の集合。  
  0 個以上の値を持てる。

- 文字列  
  JSON の文字列は必ず二重引用符(")で囲む。  
  どのような文字も「\uxxxx」(\u に続けて 4 桁の Unicode 番号)でエスケープできる。  
  バックスラッシュや改行といったコントロール文字は特殊なエスケープ表記を持っている。

- 数値  
  JSON の数値には整数と浮動小数点の両方が含まれる。  
  数値の表記は 10 進数に限る。

- ブーリアン  
  値に真か偽を取るブーリアン型はリテラルで用意されている。  
  「true」か「false」のように必ずすべてを小文字であく必要がある。
- null  
  null 値もリテラルで用意されている。  
  必ず「null」と小文字で書く必要がある。

---

## 14.5 JSONP によるクロスドメイン通信

JSON でリソース表現を提供する副次効果として、JSONP を利用できることがある。

- クロスドメイン通信の制限  
  Ajax で用いる XMLHttpRequest という JavaScript のモジュールはセキュリティ上の制限から JavaScript ファイルを取得したのと同じサーバーとしか通信ができない。  
  JavaScript があるサーバーと別のサーバーと通信ができてしまうと、ブラウザで入力した情報をユーザーが知らない間に不正なサーバーに送信できてしまうから。  
  このように複数のドメインに属するサーバーにアクセスすることをクロスドメイン通信と呼ぶ。

- script 要素による解決
  XMLHttpRequest ではクロスドメイン通信ができないが代替手段がある。  
  HTML の script 要素を用いると、複数のサイトから JavaScript ファイルを読み込みことができる。

- コールバック関数を活用する JSONP  
  JSONP はブラウザの script 要素の性質を利用して、クロスドメイン通信を実現する手法。  
  JSONP ではオリジナルの JSON をクライアントが指定したコールバック関数でラップしてドメインの異なるサーバーからデータを取得する。

---

## 14.6 ハイパーメディアフォーマットとしての JSON

JSON は JavaScript をベースにしたシンプルなデータフォーマット。  
JavaScript はもちろん、各種のプログラミング言語がライブラリを用意している。  
XML と比べると冗長性が低いという利点があるため、主にデータ表現のフォーマットとして利用されている。  
また、JSONP を使うとクロスドメイン通信ができるため、Ajax では必須の技術となっている。
JSON はデータ記述に適したフォーマットだが、リソースを表現するフォーマットとして考えた場合、ハイパーメディアフォーマットとしての側面を忘れてはならない。  
JSON をハイパーメディアフォーマットとして使うためには、リンクを表現するメンバを入れる必要がある。  
ほかのリソースとの関係を考慮して、リンクをしっかりと入れた設計をすることが大切。

---

## 第 5 部 Web サービスの設計

Web サービス WebAPI のインターフェースは HTTP と URI を用いて設計する。設計には HTTP と URI の知識が必須だが、それだけでは不十分。

---

## 15 章 読みとり専用の Web サービスの設計

---

## 15.1 リソース設計とは何か

Web サービスや WebAPI の設計と言ってもとても範囲が広い作業。
システム全体のシステム設計や、内部の作り方を示すクラス設計やデータベース設計も必要。
リソース設計とは、クライアントとサーバー間のインターフェース設計。つまり Web サービスや WebAPI の外部設計にあたる。
リソース設計をする際に大切なことは Web サービスと WebAPI を分けて考えないこと。
両者は人間用のインターフェースとプログラム用のインターフェースという違いこそあれ、どちらも同じ Web 技術を使ったインターフェース。

---

## 15.2 リソース指向のアーキテクチャ

ソフトウェア開発の世界には様々な設計手法が存在する。  
リソース設計の指針として唯一存在するのは、リソース指向アーキテクチャの設計アプローチになる。  
これは次のステップからなる設計方法。

1. Web サービスで提供するデータを特定する
2. データをリソースに分ける
3. リソースに名前を付ける
4. クライアントに提供するリソースの表現を設計する
5. リンクとフォームを利用してリソース同士を結びつける

---

## 15.3 郵便番号検索サービスの設計

---

## 15.4 データをリソースに分ける

リソース設計の最初の工程はサービスで提供するデータを理解して特定する作業。  
自分のサービスでどのようなデータを提供するのかを理解していなければリソース設計はできない。

---

## 15.5 データをリソースに分ける

次のステップではデータをリソースに分けるリソースに分割する。  
簡単そうだが大変難しい工程になる。  
データを分けたリソースのほかに、クライアントがこのサービスを利用するときに最初にアクセスするスタート地点となるリソースも必要。

---

## 15.6 リソースに URI で名前を付ける

各リソースに対して名前を付けていく作業  
プログラム向けのインターフェースの場合プログラムから扱いやすい名前にしていくことも大切。

---

## 15.7 クライアントに提供するリソースの表現を設計する

次に各リソースの表現を設計する  
Web の表現形式には得手不得手があり、1 つのリソースが複数の表現形式をサポートしていると扱いやすい。

---

## 15.8 リンクとフォームを利用してリソース同士を結びつける

Web 上に存在するリソースにはリンクが必要不可欠。  
リンクなしでは大きく価値がさがってしまう。
通常の Web サービスなどではトップページのリンクやパンくずリスト、グローバルナビなどを利用してクライアントをほかのリソースへと導いていくことが多い。

---

## 15.9 イベントの標準的なコースを検討する

Web サービスの提供者側が想定する標準的な利用コースを検討する。  
全てのリソースはステートレスなのでブラウザの検索から直接リソースを取得しても構わない。

---

## 15.10 エラーについて検討する

エラーが起きた時にどのようなステータスコードを返すのかを検討する。

- 存在しない URI を指定した  
  もっともよくあるエラー。
  404 not found を返す。

- 必須パラメータを指定していない。  
  クライアント側のミスで必須のパラメータがない場合、400 Bad Request を返す。

- サポートしていないメソッドを指定した。  
  サポートしていないメソッドをしていした場合、405 Method Not Allowed を返す。

---

## 15.11 リソース設計のスキル

シンプルなサービスでもリソース設計では様々なことを考えなければいけない。
リソース設計はスキルなので身につけることができる。

---

## 16 章 書き込み可能な Web サービスの設計

書き込み可能な Web サービスの場合、いくつか読みとりだけの場合より注意する点が増える。

---

## 16.1 書き込み可能な Web サービスの難しさ

現在の Web サービスは書き込み可能な物がほどんど。  
読み取り専用の Web サービスに比べるとユーザーからの書き込み処理がある Web サービスは考えなければならないことがたくさんある。

---

## 16.2 書き込み可能な郵便番号サービスの設計

---

## 16.3 リソースの作成

リソースの作成方法は 2 つある。  
1 つは POST する方法で、もう一つは PUT で直接作成する方法。

- ファクトリソースによる作成  
  ファクトリソースとは、リソースを作成するための特別なリソース。  
  ファクトリソースそれ自身は Web サービスによってあらかじめ用意しておき、POST で新しいリソースを作成する。

- PUT による作成  
  PUT の場合新しく作成したいリソースの URI に直接リクエストを送る。  
  作成するリソースの URI をクライアントが既に知っているためレスポンスメッセージに Location ヘッダは含めない。

---

## 16.4 リソースの更新

リソースの更新は基本的に PUT でおこなう。  
後述するバッチ更新は POST でおこなう。

- バルクアップデート  
  PUT の基本的な使い方は更新したいリソース全体をそのままメッセージボディに入れる方法。  
  リソース全体を送信する更新方法をバルクアップデートという。  
  バルクアップデートはクライアントの実装が簡単になる反面、送受信するデータが大きくなるという欠点がある。

- バーシャルアップデート  
  バルクアップデートではネットワーク帯域をたくさん使ってしまうため、Ajax などの非同期通信でユーザーからの入力の都度サーバーにデータを送信するには不都合。  
  このような場合に、リソースの一部分だけを送信するバーシャルアップデートを使用できる。  
  バーシャルアップデートは送受信するデータが少なくなる半面、GET したリソースの一部を修正してそのまま PUT するという使い方ができなくなる。

---

## 16.5 リソースの削除

リソースの削除は作成や更新に比べると単純。  
削除したいリソースの URI に DELETE を送り、リソースを削除する。  
削除を設計するときに気を付けなければならないのは、削除対象の子リソースが存在する場合。  
一般的には親リソースに従属する子リソースは、親リソースの削除に伴って削除すべき。

---

## 16.6 バッチ処理

リクエストを一回一回送信すると、サーバーへの接続回数が多くなり、パフォーマンスが落ちる場合がある。  
このような時は作成・更新したいリソースを一括で送信（バッチ処理）できるように Web サービスを設計する。

---

## 16.7 トランザクション

実際のシステムでは複数のリソースにまたがった変更をひとまとまりに扱うトランザクションが必要になるケースが多い。  
2 つの処理があった場合、片方が失敗した場合などはどちらも元の状態に戻すというのがトランザクション。

---

## 16.8 排他制御

1 つのクライアントだけを想定したリソースの更新はとても単純。  
通常の Web サービスでは、複数のクライアントを相手にしなければならない。  
排他制御とは複数のクライアントが同時に 1 つのリソースを編集して競合(Conflict)が起きないようにする仕組み。  
排他制御の方法は大きく分けて、悲観的ロックと楽観的ロックの二つがある。

- 悲観的ロック  
  悲観的ロックとはユーザーをあまり信頼せずに、競合が発生しないようにする排他制御の仕組み。  
  HTTP で悲観的ロックを行う場合は、WebDev の LOCK/UNLOCK メソッドを使う方法と、独自のロックリソースを使う方法がある。  
  悲観的ロックではリソース編集の競合が決して起きないようにするためにロックの権限を持った人以外が編集できないように制限する

- 楽観的ロック  
  悲観的ロックは規模が大きくなるにつれてロックしたまま編集ができなくなるなどの問題が浮上する。  
  これに対して、常に同じリソースを編集し続けることは少ないという経験則から通常の編集ではロックをせずに競合が起きた時に対処する仕組みを楽観的ロックという。

---

## 16.9 設計のバランス

設計はバランスを取る作業。  
あちらを立てればこちらが立たずということがよくある。  
各種のパラメータを加味して、自分が最もバランスがとれていると感じるところに落ち着かせるのが設計作業。  
以下の項目を参考にするとよい。

- なるべくシンプルに保つ
- 困ったらリソースに戻って考える
- 本当に必要なら POST で何でもできる

---

## 17 章 リソースの設計

リソースの設計にはいまだに定石がないためいざリソース設計をはじめても何から手を付けていいかわからなくなる。  
何にリソースとして名前(URI)を与えるのかを判断するところは苦労する。

---

## 17.1 リソースアーキテクチャのアプローチ落とし穴

リソース指向アーキテクチャの設計アプローチには罠が潜んでいる。  
「Web サービスで提供するデータを特定」し、「データをリソースに分ける」方法がわからない。  
既存の設計手法で得られた成果物をもとにリソースを設計する方法配下のようなものがある。

- 関係モデル図の ER 図
- オブジェクト指向モデルのクラス図
- 情報アーキテクチャ

---

## 17.2 関係モデルからの導出

関係モデルは RDBMS の基礎となっているデータモデルであり、数学的基盤を持っていることが特徴。  
データの冗長性を排除するための正規化の手法が確立されており、効率的なデータベース設計ができる。

---

## 17.3 オブジェクト指向モデルからの導出

オブジェクト指向設計は対象システムの分析モデルをオブジェクト指向言語のクラスとインスタンスに対応付ける。  
オブジェクト指向設計の成果物として、クラス図やシーケンス図がある。

---

## 17.4 情報アーキテクチャからの導出

情報アーキテクチャは関係モデルやオブジェクト指向モデルに比べると新しい概念。  
従来の紙の上の 2 次元のグラフィックデザインと比べてユーザーの操作やページ遷移、ネットワーク通信、アプリケーションの実行など複雑になっている。  
情報アーキテクチャはこの複雑になったデザインを図書館情報学などの情報分類の観点から整理して受け手にとって情報を探しやすくしたり、分かりやすく伝えるための技術。

---

## 17.5 リソース設計で最も重要なこと

リソースを設計する時は、Web サービスと WebAPI を分けて考えないことがとても重要。  
これが最も重要な考え方。

---

# 感想

普段自分が担当している領域が、Web の中のどういった部分なのかを改めて理解することができた。  
知っていることも知らないこともあったが Web の発展の歴史から学ぶことができ、技術の進化も感じることができた。  
いろいろな技術が出てきているが、基礎的なこういった部分をしっかり押さえておくことで新しい物に対してのキャッチアップがしやすくなると感じた。

- 実践的な図解が多かったものは気力が尽きて省きました。。。
